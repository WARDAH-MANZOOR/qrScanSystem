// schema.prisma

datasource db {
  provider = "postgresql" // Assuming PostgreSQL
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

enum TransactionStatus {
  completed
  pending
  failed
}

enum TransactionType {
  purchase
  refund
  chargeback
}

model Transaction {
  transaction_id   Int               @id @unique @default(autoincrement())
  date_time        DateTime
  original_amount  Decimal?          @db.Decimal(10, 2)
  issuer_id        Int
  issuer           Issuer            @relation(fields: [issuer_id], references: [issuer_id])
  status           TransactionStatus
  type             TransactionType
  response_message String?
  settlement       Boolean           @default(false)
  settled_amount   Decimal?          @db.Decimal(10, 2)
  pan_details      PANDetails?
  merchant_id      Int               
  merchant         Merchant          @relation(fields: [merchant_id], references: [merchant_id])
}

model PANDetails {
  pan_details_id Int         @id @default(autoincrement())
  transaction_id Int         @unique
  transaction    Transaction @relation(fields: [transaction_id], references: [transaction_id])
  pan            String
  stan           String

  @@map("pan_details")
}

model Issuer {
  issuer_id    Int           @id @default(autoincrement())
  issuer_name  String
  transactions Transaction[]

  @@map("issuer")
}

model Merchant {
  merchant_id    Int           @id @default(autoincrement())
  full_name      String
  phone_number   String
  email          String
  company_name   String
  company_url    String?
  city           String
  payment_volume Decimal?      @db.Decimal(10, 2)
  transactions   Transaction[]
  user_groups    UserGroup[] // Associate UserGroups with Merchant
  users           User[]
}

model User {
  id       Int         @id @default(autoincrement())
  username String
  email    String      @unique
  password String
  age      Int?
  groups   UserGroup[]
  merchant_id  Int         // merchant association
  merchant Merchant   @relation(fields: [merchant_id], references: [merchant_id]) // Optionally associate a user with a merchant
  @@unique([email, merchant_id]) // Ensure unique combination of email and merchant
}

model Group {
  id          Int               @id @default(autoincrement())
  name        String            @unique
  permissions GroupPermission[]
  users       UserGroup[]
}

model Permission {
  id     Int               @id @default(autoincrement())
  name   String            @unique
  groups GroupPermission[]
}

model UserGroup {
  userId     Int
  groupId    Int
  user       User      @relation(fields: [userId], references: [id])
  group      Group     @relation(fields: [groupId], references: [id])
  merchantId Int  // merchant association
  merchant   Merchant @relation(fields: [merchantId], references: [merchant_id])

  @@id([userId, groupId])
}

model GroupPermission {
  groupId      Int
  permissionId Int
  group        Group      @relation(fields: [groupId], references: [id])
  permission   Permission @relation(fields: [permissionId], references: [id])

  @@id([groupId, permissionId])
}

model ScheduledTask {
  id            Int       @id @default(autoincrement())
  transactionId Int?
  status        String    @db.VarChar(50)
  scheduledAt   DateTime? @db.Timestamptz
  executedAt    DateTime? @db.Timestamptz
}
